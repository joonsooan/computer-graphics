// 05-both-cameras.js
// - PerspectiveCamera vs OrthographicCamera
// - OrbitControl change when camera changes

import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import Stats from "three/addons/libs/stats.module.js";
import { GUI } from "three/addons/libs/lil-gui.module.min.js";

const scene = new THREE.Scene();

// Camera를 perspective와 orthographic 두 가지로 switching 해야 해서 const가 아닌 let으로 선언
let camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.x = 120;
camera.position.y = 60;
camera.position.z = 180;
camera.lookAt(scene.position);
scene.add(camera);

const renderer = new THREE.WebGLRenderer();
renderer.setClearColor(new THREE.Color(0x000000));
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const stats = new Stats();
document.body.appendChild(stats.dom);

// Camera가 바뀔 때 orbitControls도 바뀌어야 해서 let으로 선언
let orbitControls = new OrbitControls(camera, renderer.domElement);
orbitControls.enableDamping = true;

const planeGeometry = new THREE.PlaneGeometry(180, 180);
const planeMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
const plane = new THREE.Mesh(planeGeometry, planeMaterial);
plane.rotation.x = -0.5 * Math.PI;
plane.position.x = 0;
plane.position.y = 0;
plane.position.z = 0;
scene.add(plane);

const cubeGeometry = new THREE.BoxGeometry(4, 4, 4);

// bunch of cubes
for (let j = 0; j < planeGeometry.parameters.height / 5; j++) {
  for (let i = 0; i < planeGeometry.parameters.width / 5; i++) {
    const rnd = Math.random() * 0.75 + 0.25; // 0.25 ~ 1.00 사이의 랜덤 수 (random color)
    const cubeMaterial = new THREE.MeshLambertMaterial();
    cubeMaterial.color = new THREE.Color(rnd, 0, 0);
    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube.position.z = -(planeGeometry.parameters.height / 2) + 2 + j * 5;
    cube.position.x = -(planeGeometry.parameters.width / 2) + 2 + i * 5;
    cube.position.y = 2;

    scene.add(cube);
  }
}

const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
directionalLight.position.set(-20, 40, 60);
scene.add(directionalLight);

const ambientLight = new THREE.AmbientLight(0x292929);
scene.add(ambientLight);

let step = 0;

// GUI
const gui = new GUI();
const controls = new (function () {
  this.perspective = "Perspective";
  this.switchCamera = function () {
    if (camera instanceof THREE.PerspectiveCamera) {
      scene.remove(camera);
      camera = null; // 기존의 camera 제거
      // OrthographicCamera(left, right, top, bottom, near, far)
      camera = new THREE.OrthographicCamera(
        window.innerWidth / -16,
        window.innerWidth / 16,
        window.innerHeight / 16,
        window.innerHeight / -16,
        -200,
        500
      );
      camera.position.x = 120;
      camera.position.y = 60;
      camera.position.z = 180;
      camera.lookAt(scene.position);
      orbitControls.dispose(); // 기존의 orbitControls 제거
      orbitControls = null;
      orbitControls = new OrbitControls(camera, renderer.domElement);
      orbitControls.enableDamping = true;
      this.perspective = "Orthographic";
    } else {
      scene.remove(camera);
      camera = null;
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.x = 120;
      camera.position.y = 60;
      camera.position.z = 180;
      camera.lookAt(scene.position);
      orbitControls.dispose(); // 기존의 orbitControls 제거
      orbitControls = null;
      orbitControls = new OrbitControls(camera, renderer.domElement);
      orbitControls.enableDamping = true;
      this.perspective = "Perspective";
    }
  };
})();
gui.add(controls, "switchCamera");
gui.add(controls, "perspective").listen();

//const clock = new THREE.Clock();

render();

function render() {
  orbitControls.update();
  stats.update();

  // render using requestAnimationFrame
  requestAnimationFrame(render);
  renderer.render(scene, camera);
}
